package dev.mathops.persistence.config;

import dev.mathops.commons.builder.SimpleBuilder;
import dev.mathops.commons.file.FileLoader;
import dev.mathops.commons.log.Log;
import dev.mathops.commons.parser.ParsingException;
import dev.mathops.commons.parser.json.JSONObject;
import dev.mathops.commons.parser.json.JSONParser;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

/**
 * A container for all configuration state, with utility methods to load and store the state.
 */
public final class DataLayerConfig {

    /** The configuration directory. */
    private final File configDir;

    /** The list of loaded schemas (each with their contexts and tables). */
    private final List<SchemaConfig> schemas;

    /** The list of loaded implementations. */
    private final List<ImplementationConfig> implementations;

    /** The list of loaded roles. */
    private final List<RoleConfig> roles;

    /** The list of loaded logins. */
    private final List<LoginConfig> logins;

    /** The list of loaded data configurations. */
    private final List<DataConfiguration> configurations;

    /** The list of warning messages generated by a "load" operation. */
    private final List<String> warnings;

    /** The list of error messages generated by a "load" operation. */
    private final List<String> errors;

    /**
     * Constructs a new {@code DataLayerConfig}.
     *
     * @param theConfigDir the configuration directory
     */
    DataLayerConfig(final File theConfigDir) {

        this.configDir = theConfigDir;

        this.schemas = new ArrayList<>(10);
        this.implementations = new ArrayList<>(10);
        this.roles = new ArrayList<>(10);
        this.logins = new ArrayList<>(10);
        this.configurations = new ArrayList<>(10);
        this.warnings = new ArrayList<>(10);
        this.errors = new ArrayList<>(10);
    }

    /**
     * Attempts to load state.  This operation may accumulate errors or warnings about state.
     *
     * @return {@code true} if a usable state was loaded (possibly with warnings), {@code false} if not
     */
    boolean isLoadOk() {

        this.schemas.clear();
        this.implementations.clear();
        this.roles.clear();
        this.logins.clear();
        this.configurations.clear();
        this.warnings.clear();
        this.errors.clear();

        final boolean schemasOk = isSchemasFileOk();
        final boolean implementationsOk = isImplementationsFileOk();
        final boolean rolesOk = isRolesFileOk();
        final boolean loginsOk = isLoginsFileOk();
        final boolean configurationsOk = isConfigurationsFileOk();

        return schemasOk && implementationsOk && rolesOk && loginsOk && configurationsOk;
    }

    /**
     * Attempts to load schemas from "schemas.json".
     *
     * @return {@code true} if a usable state was loaded (possibly with warnings), {@code false} if not
     */
    private boolean isSchemasFileOk() {

        boolean ok = true;

        final File file = new File(this.configDir, "schemas.json");

        final String contents = FileLoader.loadFileAsString(file, true);
        if (contents == null) {
            final String dirPath = this.configDir.getAbsolutePath();
            final String msg = SimpleBuilder.concat("'schemas.json' file not found in ", dirPath);
            this.errors.add(msg);
        } else {
            try {
                final Object parsed = JSONParser.parseJSON(contents);

                if (parsed instanceof final Object[] array) {
                    for (final Object item : array) {
                        if (item instanceof final JSONObject obj) {
                            ok = ok && isSchemaObjectOk(obj);
                        } else {
                            final String dirPath = this.configDir.getAbsolutePath();
                            final String clsName = item.getClass().getName();
                            final String msg = SimpleBuilder.concat("Unexpected object type (", clsName,
                                    "), expecting OBJECT with schema definition in 'schemas.json' in ", dirPath);
                            this.warnings.add(msg);
                        }
                    }
                } else if (parsed instanceof final JSONObject obj) {
                    ok = isSchemaObjectOk(obj);
                } else {
                    final String dirPath = this.configDir.getAbsolutePath();
                    final String clsName = parsed.getClass().getName();
                    final String msg = SimpleBuilder.concat("Unexpected object type (", clsName,
                            "), expecting OBJECT with schema definition in 'schemas.json' in ", dirPath);
                    this.warnings.add(msg);
                }
            } catch (final ParsingException ex) {
                Log.warning(ex);
                final String dirPath = this.configDir.getAbsolutePath();
                final String msg = SimpleBuilder.concat("Unable to parse 'schemas.json' in ", dirPath);
                this.errors.add(msg);
            }
        }

        return ok;
    }

    /**
     * Attempts to extract schema configuration from a JSON object.
     *
     * @param obj the JSON object
     * @return {@code true} if a usable state was loaded (possibly with warnings), {@code false} if not
     */
    private boolean isSchemaObjectOk(final JSONObject obj) {

        boolean ok = true;

        SchemaConfig config = null;

        final String schemaName = obj.getStringProperty("schema-name");
        if (schemaName == null) {
            final String dirPath = this.configDir.getAbsolutePath();
            final String msg = SimpleBuilder.concat("Missing schema name in 'schemas.json' in ", dirPath);
            this.errors.add(msg);
            ok = false;
        } else {
            config = new SchemaConfig(schemaName);
        }

        final Object contexts = obj.getProperty("contexts");
        if (contexts == null) {
            final String dirPath = this.configDir.getAbsolutePath();
            final String msg = SimpleBuilder.concat("Missing contexts array in 'schemas.json' [", schemaName, "] in ",
                    dirPath);
            this.errors.add(msg);
            ok = false;
        }

        if (contexts instanceof Object[] contextsArray) {
            for (final Object inner : contextsArray) {
                if (inner instanceof JSONObject contextObj) {
                    ok &= isSchemaContextOk(contextObj, config);
                } else {
                    final String dirPath = this.configDir.getAbsolutePath();
                    final String clsName = inner.getClass().getName();
                    final String msg = SimpleBuilder.concat("Unexpected object type (", clsName,
                            "), expecting OBJECT with context definition in 'schemas.json' [", schemaName, "] in ",
                            dirPath);
                    this.warnings.add(msg);
                }
            }
        } else {
            final String dirPath = this.configDir.getAbsolutePath();
            final String clsName = contexts.getClass().getName();
            final String msg = SimpleBuilder.concat("Unexpected object type (", clsName,
                    "), expecting array of contexts in 'schemas.json' [", schemaName, "] in ", dirPath);
            this.warnings.add(msg);
        }

        final Object tables = obj.getProperty("tables");
        if (tables == null) {
            final String dirPath = this.configDir.getAbsolutePath();
            final String msg = SimpleBuilder.concat("Missing tables array in 'schemas.json' [", schemaName, "] in ",
                    dirPath);
            this.errors.add(msg);
            ok = false;
        }

        if (tables instanceof Object[] tablesArray) {
            for (final Object inner : tablesArray) {
                if (inner instanceof JSONObject tableObj) {
                    ok &= isSchemaTableOk(tableObj, config);
                } else {
                    final String dirPath = this.configDir.getAbsolutePath();
                    final String clsName = inner.getClass().getName();
                    final String msg = SimpleBuilder.concat("Unexpected object type (", clsName,
                            "), expecting OBJECT with table definition in 'schemas.json' [", schemaName, "] in ",
                            dirPath);
                    this.warnings.add(msg);
                }
            }
        } else {
            final String dirPath = this.configDir.getAbsolutePath();
            final String clsName = tables.getClass().getName();
            final String msg = SimpleBuilder.concat("Unexpected object type (", clsName,
                    "), expecting array of contexts in 'schemas.json' [", schemaName, "] in ", dirPath);
            this.warnings.add(msg);
        }

        if (config != null) {
            final int numContexts = config.getNumContexts();
            if (numContexts == 0) {
                final String dirPath = this.configDir.getAbsolutePath();
                final String msg = SimpleBuilder.concat("Schema defined with no contexts in 'schemas.json' [",
                        schemaName, "] in ", dirPath);
                this.errors.add(msg);
                ok = false;
            }

            final int numtables = config.getNumTables();
            if (numtables == 0) {
                final String dirPath = this.configDir.getAbsolutePath();
                final String msg = SimpleBuilder.concat("Schema defined with no tables in 'schemas.json' [",
                        schemaName, "] in ", dirPath);
                this.errors.add(msg);
                ok = false;
            }
        }

        return ok;
    }

    /**
     * Attempts to extract context configuration from a JSON object within a schema configuration.
     *
     * @param obj the JSON object
     * @param config the schema to which to add the context configuration if valid
     * @return {@code true} if a usable state was loaded (possibly with warnings), {@code false} if not
     */
    private boolean isSchemaContextOk(final JSONObject obj, final SchemaConfig config) {

        return false;
    }

    /**
     * Attempts to extract table configuration from a JSON object within a schema configuration.
     *
     * @param obj the JSON object
     * @param config the schema to which to add the table configuration if valid
     * @return {@code true} if a usable state was loaded (possibly with warnings), {@code false} if not
     */
    private boolean isSchemaTableOk(final JSONObject obj, final SchemaConfig config) {

        return false;
    }

    /**
     * Attempts to load implementations from "schemas.json".
     *
     * @return {@code true} if a usable state was loaded (possibly with warnings), {@code false} if not
     */
    private boolean isImplementationsFileOk() {

        return false;
    }

    /**
     * Attempts to load roles from "schemas.json".
     *
     * @return {@code true} if a usable state was loaded (possibly with warnings), {@code false} if not
     */
    private boolean isRolesFileOk() {

        return false;
    }

    /**
     * Attempts to load logins from "schemas.json".
     *
     * @return {@code true} if a usable state was loaded (possibly with warnings), {@code false} if not
     */
    private boolean isLoginsFileOk() {

        return false;
    }

    /**
     * Attempts to load data configurations from "schemas.json".
     *
     * @return {@code true} if a usable state was loaded (possibly with warnings), {@code false} if not
     */
    private boolean isConfigurationsFileOk() {

        return false;
    }

    /**
     * Attempts to store the configuration to its directory.
     *
     * @return {@code true} if state was stored successfully, {@code false} if not
     */
    boolean store() {

        return false;
    }
}